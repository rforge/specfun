
R version 2.15.0 beta (2012-03-20 r58793)
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(Bessel)
Loading required package: Rmpfr
Loading required package: gmp

Attaching package: 'gmp'

The following object(s) are masked from 'package:base':

    %*%, apply, crossprod, matrix, tcrossprod

Loading C code of R package 'Rmpfr': GMP using 64 bits per limb

Attaching package: 'Rmpfr'

The following object(s) are masked from 'package:stats':

    pnorm, print.integrate

The following object(s) are masked from 'package:base':

    cbind, pmax, pmin, rbind

> 
> #### Test cases for the Bessel functions I(), J(), K(), Y()
> ####                    -----------------------------------
> 
> paste0 <- function(...) paste(..., sep="")
> ### --- For real arguments -- Comparisons with bessel[IJYK]()
> 
> x <- c(1e-6, 0.1, 1:10, 20, 100, 200)# larger x : less (relative) accuracy (??)
> nus <- c(-6, -5.9, -1.1, .1, 1:4, 10, 20)
> ## From R 2.10.1 (or 2.10.0 patched, >= Nov.23 2009) on, this works, previously
> ## 	R"s  besselJ() had an inaccuracy that we have corrected here !
> ## FIXME ? ---- we currently need to fudge for negative nu
> ## note that (nu != -6 but nu ~ -6, |x| << |nu|) is still unstable,
> ## since sin(nu*pi) ~ 0 (but not exactly!) and besselK() is large
> nS <- 10
> for(F in c("I","J","K","Y")) {
+     cat("\n", F," ---  nu : ")
+     zF <- get(paste0("Bessel", F))
+     FF <- get(paste0("bessel", F))
+     stopifnot(is.function(zF), is.function(FF))
+     for(nu in nus) {
+         x. <- x
+         spec <- FALSE ## nu < 0 && F %in% c("I","J")
+         cat(format(nu), if(spec)"* " else " ", sep="")
+         zr <- zF(x., nu, nSeq = nS)
+         rr <- outer(x., nu+ sign(nu)*(seq_len(nS)-1), FF)
+         stopifnot(all.equal(zr, rr, tol = 500e-16))
+     }; cat("\n")
+ }

 I  ---  nu : -6 -5.9 -1.1 0.1 1 2 3 4 10 20 

 J  ---  nu : -6 -5.9 -1.1 0.1 1 2 3 4 10 20 

 K  ---  nu : -6 -5.9 -1.1 0.1 1 2 3 4 10 20 

 Y  ---  nu : -6 -5.9 -1.1 0.1 1 2 3 4 10 20 
> 
> zr[,1]
 [1] -4.060174e+142  -4.060708e+42  -4.113970e+22  -4.081651e+16  -1.311354e+13
 [6]  -4.563720e+10  -5.933965e+08  -1.794946e+07  -9.814739e+05  -8.349290e+04
[11]  -1.003640e+04  -1.597484e+03  -2.854895e-01   5.124797e-02  -4.238574e-02
> 
> ### *Large* arguments ,
> ### However, base::bessel*(): only I() and K() have 'expon.scaled'
> 
> x <- 1000*(1:20)
> str(rI <- BesselI(x, 10, nSeq = 5, expon.scaled=TRUE))
 num [1:20, 1:5] 0.012 0.0087 0.00716 0.00623 0.00559 ...
> rI
             [,1]        [,2]        [,3]        [,4]        [,5]
 [1,] 0.012001595 0.011876177 0.011740319 0.011594410 0.011438864
 [2,] 0.008700860 0.008655289 0.008605651 0.008552021 0.008494475
 [3,] 0.007163547 0.007138514 0.007111198 0.007081624 0.007049824
 [4,] 0.006229659 0.006213326 0.006195486 0.006176153 0.006155341
 [5,] 0.005585892 0.005574173 0.005561366 0.005547478 0.005532519
 [6,] 0.005107685 0.005098753 0.005088989 0.005078397 0.005066983
 [7,] 0.004734417 0.004727320 0.004719559 0.004711139 0.004702061
 [8,] 0.004432588 0.004426774 0.004420414 0.004413512 0.004406070
 [9,] 0.004181980 0.004177104 0.004171769 0.004165979 0.004159734
[10,] 0.003969574 0.003965408 0.003960850 0.003955902 0.003950565
[11,] 0.003786557 0.003782944 0.003778991 0.003774699 0.003770069
[12,] 0.003626723 0.003623550 0.003620079 0.003616310 0.003612244
[13,] 0.003485557 0.003482742 0.003479663 0.003476318 0.003472710
[14,] 0.003359687 0.003357168 0.003354411 0.003351418 0.003348187
[15,] 0.003246537 0.003244265 0.003241779 0.003239078 0.003236164
[16,] 0.003144099 0.003142037 0.003139779 0.003137327 0.003134681
[17,] 0.003050784 0.003048900 0.003046838 0.003044599 0.003042182
[18,] 0.002965312 0.002963583 0.002961690 0.002959634 0.002957415
[19,] 0.002886644 0.002885049 0.002883303 0.002881407 0.002879360
[20,] 0.002813922 0.002812445 0.002810828 0.002809072 0.002807176
> str(rK <- BesselK(x, 10, nSeq = 5, expon.scaled=TRUE))
 num [1:20, 1:5] 0.0417 0.0287 0.0233 0.0201 0.0179 ...
> 
> if(getRversion() >= "2.8.2") { ## besselI(), besselJ() with larger working range
+     r2 <- outer(x, 10+seq_len(5)-1,
+                 besselI, expon.scaled=TRUE)
+     stopifnot(all.equal(rI, r2, tol = 8e-16))
+ } ## R >= 2.8.2
> 
> r2 <- outer(x, 10+seq_len(5)-1,
+             besselK, expon.scaled=TRUE)
> stopifnot(all.equal(rK, r2, tol = 8e-16))
> 
> ###--------------------- Complex  Arguments ------------------------------
> 
> ## I would expect that   besselIasym()  work too {should according to Abramowitz&Stegun!}
> ## but they seem complete "nonsense":
> 
> ## e.g.
> z <- 10000*(1 + 1i)
> BesselI       (z, 10, expon.scaled=TRUE) ##  -0.003335734 + 0.000266159i
[1] -0.003335734+0.000266159i
> besselIasym   (z, 10, expon.scaled=TRUE) ## very different
[1] 0.003094795-0.001272873i
> besselI.nuAsym(z, 10, expon.scaled=TRUE, k.max=3) ## (same)
[1] 0.003094795-0.001272873i
> 
> ##  J(i * z, nu) =  c(nu) * I(z, nu)
> 
> ## for *integer* nu, it's simple
> N <- 100
> set.seed(1)
> for(nu in 0:20) {
+     cat(nu, "")
+     z <- complex(re = rnorm(N),
+                  im = rnorm(N))
+     r <- BesselJ(z * 1i, nu) / BesselI(z, nu)
+     stopifnot(all.equal(r, rep.int(exp(nu/2*pi*1i), N)))
+ }; cat("\n")
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
> 
> nus <- round(sort(rlnorm(20)), 2)
> 
> if(FALSE) { ## Bug ??
+ ## For fractional nu, there's a problem (?) :
+ for(nu in nus) {
+     cat("nu=", formatC(nu, wid=6),":")
+     z <- complex(re = rnorm(N),
+                  im = rnorm(N))
+     r <- BesselJ(z * 1i, nu) / BesselI(z, nu)
+     r.Theory <- exp(nu/2*pi*1i)
+     cat("correct:"); print(table(Ok <- abs(1 - r /r.Theory) < 1e-7))
+     cat("log(<wrong>) / (i*pi/2) :",
+         format(unique(log(signif(r[!Ok], 6)))/(pi/2 * 1i)),
+         "\n")
+ }
+ 
+ }# not for now
> 
> 
> ### Replicate some testing "ideas" from  zqcbi.f (TOMS 644 test program)
> 
> ##   zqcbi is a quick check routine for the complex i bessel function
> ##   generated by subroutine zbesi.
> ##
> ##   zqcbk generates sequences of i and k bessel functions from
> ##   zbesi and cbesk and checks the wronskian evaluation
> ##
> ##         I(nu,z)*K(nu+1,z) + I(nu+1,z)*K(nu,z) = 1/z
> ##
> ##   in the right half plane and a modified form
> ##
> ##        I(nu+1,z)*K(nu,zr) - I(nu,z)*K(nu+1,zr) = c/z
> ##
> ##   in the left half plane where zr: = -z and c := exp(nu*sgn*pi*i) with
> ##   sgn=+1 for Im(z) >= 0 and sgn=-1 for Im(z) < 0.          ^^^
> ##                                                          ( ||| corrected, MM)
> N <- 100
> nS <- 20
> set.seed(257)
> 
> nus. <- unique(sort(c(nus,10*nus)))
> ## For exploration nus. <- (1:80)/4
> for(i in seq_along(nus.)) {
+     nu <- nus.[i]
+     cat(nu, "")
+     z <- complex(re = rnorm(N),
+                  im = rnorm(N))
+     P <- Re(z) >= 0
+     rI  <- BesselI( z,     nu, nSeq = 1+nS) # -> for (nu, nu+1, ...,nu+nS)
+     rKp <- BesselK( z[ P], nu, nSeq = 1+nS)
+     rKm <- BesselK(-z[!P], nu, nSeq = 1+nS)
+     ##
+     sgn <- ifelse(Im(z) >= 0, +1, -1)
+     Izp <- 1 / z [ P]
+     for(j in 1:nS) {
+         nu.. <- nu + j-1
+         allEQ <- function(x,y) all.equal(x,y, tol= max(1,nu..)*nS*2e-15)
+         c. <- exp(pi*nu..*sgn*1i)
+         Izm <- (c./z)[!P]
+         stopifnot(allEQ(rI[ P,j  ]*rKp[,j+1] + rI[ P,j+1]*rKp[,j  ], Izp),
+                   allEQ(rI[!P,j+1]*rKm[,j  ] - rI[!P,j  ]*rKm[,j+1], Izm) )
+     }
+ }; cat("\n")
0.07 0.11 0.19 0.23 0.38 0.55 0.56 0.7 0.86 1.03 1.1 1.43 1.79 1.86 1.89 1.9 1.94 2.24 2.3 2.8 2.91 3.32 3.62 3.8 5.5 5.6 6.28 8.6 10.3 14.3 17.9 18.6 18.9 19.4 22.4 28 29.1 33.2 36.2 62.8 
> 
> 
> ### Replicate some testing "ideas" from  zqcbk.f (TOMS 644 test program)
> 
> ##  part 1) in the right half plane ----> see above (I & K)
> ##  part 2)
> ##      the analytic continuation formula
> ##     for H(nu,2,z) in terms of the K function
> ##
> ##           K(nu,z) = c3*H(nu,2,zr) + c4*H(nu,1,zr)    Im(z) >= 0
> ##                   =  conjg(K(nu,conjg(z)))           Im(z) < 0
> ##
> ##     in the left half plane where c3=c1*conjg(c2)*c5, c4 = c2*c5
> ##     c1=2*cos(pi*nu),   c2=exp(pi*nu*i/2),   c5 =-pi*i/2   and
> ##     zr = z*exp(-3*pi*i/2) = z*i
> 
> 
> ### Replicate some testing "ideas" from  zqcbj.f (TOMS 644 test program)
> 
> ##     zqcbj is a quick check routine for the complex J bessel function
> ##     generated by subroutine zbesj.
> ##
> ##     zqcbj generates sequences of J and H bessel functions from zbesj
> ##     and zbesh and checks the wronskians
> ##
> ##     J(nu,z)*H(nu+1,1,z) - J(nu+1,z)*H(nu,1,z) =  2/(pi*i*z)   y >= 0
> ##     J(nu,z)*H(nu+1,2,z) - J(nu+1,z)*H(nu,2,z) = -2/(pi*i*z)   y < 0
> ##
> ##     in their respective half planes,  y = Im(z)
> 
> N <- 100
> nS <- 20
> set.seed(47)
> 
> for(i in seq_along(nus.)) {
+     nu <- nus.[i]
+     cat(nu, "")
+     z <- complex(re = rnorm(N),
+                  im = rnorm(N))
+     P <- Im(z) >= 0
+     rJ  <- BesselJ(  z,     nu, nSeq = 1+nS) # -> for (nu, nu+1, ...,nu+nS)
+     rH1 <- BesselH(1,z[ P], nu, nSeq = 1+nS)
+     rH2 <- BesselH(2,z[!P], nu, nSeq = 1+nS)
+     ##
+     sgn <- ifelse(Im(z) >= 0, +1, -1)
+     Iz <- 2/(pi*1i*z)
+     for(j in 1:nS) {
+         nu.. <- nu + j-1
+         allEQ <- function(x,y) all.equal(x,y, tol= max(1,nu..)*nS*1e-15)
+         stopifnot(allEQ(rJ[ P,j]*rH1[,j+1] - rJ[ P,j+1]*rH1[,j],  Iz[ P]),
+                   allEQ(rJ[!P,j]*rH2[,j+1] - rJ[!P,j+1]*rH2[,j], -Iz[!P]) )
+     }
+ }; cat("\n")
0.07 0.11 0.19 0.23 0.38 0.55 0.56 0.7 0.86 1.03 1.1 1.43 1.79 1.86 1.89 1.9 1.94 2.24 2.3 2.8 2.91 3.32 3.62 3.8 5.5 5.6 6.28 8.6 10.3 14.3 17.9 18.6 18.9 19.4 22.4 28 29.1 33.2 36.2 62.8 
> 
> 
> ### TODO __FIXME__
> 
> ### Replicate some testing "ideas" from  zqcby.f (TOMS 644 test program)
> 
> ##     zqcby generates sequences of y bessel functions from zbesy and
> ##     zbesyh and compares them for a variety of values in the (z,nu)
> ##     space. zbesyh is an old version of zbesy which computes the y
> ##     function from the h functions of kinds 1 and 2.
> 
> ###--------> zbesyh() in ../src/zbsubs.c  is completely unneeded (otherwise) !
> 
> 
> ##  "limit  z -> 0  does not exist (there are many complex "Inf"s),
> ##		    but for z = real, z >=0 is -Inf
> stopifnot(BesselY(0,1) == -Inf,# == besselY(0,1),
+ 	  is.nan(BesselY(0+0i, 1)))
> 
> proc.time()
   user  system elapsed 
  2.378   0.083   2.577 
